# Shell学习笔记



## 输入输出重定向

### 1. 标准输入输出

| 设备   | 设备文件名  | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/sdtout | 1          | 标准输出     |
| 显示器 | /dev/sdterr | 2          | 标准错误输出 |

### 2. 输出重定向

| 类型                                              | 符号                    | 作用                                                       |
| ------------------------------------------------- | ----------------------- | ---------------------------------------------------------- |
| 标准输出重定向                                    | 命令 > 文件             | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中   |
|                                                   | 命令 >> 文件            | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中   |
| 标准错误输出重定向                                | 错误命令 2> 文件        | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。 |
|                                                   | 错误命令 2>> 文件       | 以追加的方式，把命令的错误输出输出到指定的文件中。         |
| <font color=red>正确输出和错误输出同时保存</font> | 命令 > 文件 2>&1        | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中   |
|                                                   | 命令 >> 文件 2>&1       | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中   |
|                                                   | 命令 &> 文件            | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中   |
|                                                   | 命令 &>> 文件           | 以追加的方式，把正确输出和错误输出都保存到同一个文件中     |
|                                                   | 命令 >> 文件1 2>> 文件2 | 把正确的输出追加到文件1中，把错误的输出追加到文件2中       |

有一种常用的方式

```shell
ls &>> /dev/null  #  将命令的正确输出和错误输出都输出到黑洞中
```





### 3. 输入重定向

`命令 < 文件` 把文件作为命令的输入

例子： wc统计文件中的 行、词、字节

```java
public class Demo2 {
    public static void main(String[] args) throws InterruptedException {
        while (true) {
            System.out.println("hello");
            Thread.sleep(1000);
        }
    }
}
```

```shell
[hadoop@kube-master1 Files]$ wc < Demo2.java 
  8  20 216
```



## 多命令顺序执行与管道符

### 命令顺序执行，逻辑与执行，逻辑或执行

| 多命令执行 | 格式             | 作用                                                         |
| ---------- | ---------------- | ------------------------------------------------------------ |
| `;`        | `命令1 ; 命令2`  | 多个命令顺序执行，命令之间没有任何逻辑联系                   |
| `&&`       | `命令1 && 命令2` | 逻辑与<br />当命令1正确执行，则命令2才会执行<br />当命令1执行不正确，则命令2不会执行 |
| `||`       | `命令1 || 命令2` | 逻辑或<br />当命令1执行不正确，则命令2才会执行<br />当命令1正确执行，则命令2不会执行 |

举例：

1. 统计磁盘复制时间

```shell
# dd 命令 复制磁盘
dd if=输入文件 of=输出文件 bs=字节数 count=个数
选项：
	if=输入文件		指定源文件或源设备
	of=输出文件		执行目标文件或目标设备
	bs=字节数		 指定一次输入/输出多少字节，即把这些字节看做一个数据块
	count=个数	  指定输入/输出多少个数据块
root@localhost~]# date; dd if=/dev/zero of=/root/testfile bs=1k count=100000; date
# 上述命令可以查看复制磁盘数据所花费的时间

```

2. 编译软件(`configure`完成后才可以`make`完成后才可以执行`make install` )

```shell
./configure && make && make install
```

例子2：

```shell
[root@localhost ~]# 命令 && echo yes || echo no
# 如果 命令执行成功 则输出 yes ，如果命令执行失败，则输出 no
```



### 管道符

```shell
[root@loaclhost ~]# 命令1 | 命令2
# 命令1的正确输出作为命令2的操作对象
```



`grep`命令

```shell
grep [选项] "搜索内容" 文件
选项：
	-i		忽略大小写
	-n		输出行号
	-v		反向查找（查找处理需要查找关键内容 之外 的 内容）
	--color=auto	搜索出的关键字用颜色显示

例如：
grep -v "abc" text.java  # 查找除了包含abc之外的内容
```





## 通配符和其他特殊符号

| 通配符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ?      | 匹配一个任意字符                                             |
| *      | 匹配0个或任意多个任意字符，也就是可以匹配任何内容；例如删除一个文件夹中的所有文件：`rm -rf /home/files/*` |
| []     | 匹配中括号中的任意一个字符，例如：`[abc]`代表一定匹配一个字符，要么是`a`，要么是`b`，要么是`c`。 |
| [-]    | 匹配中括号中任意一个字符，`-`代表一个范围，例如`[a-z]`代表匹配一个a到z的小写字母 |
| [^]    | 逻辑非，表示匹配不是中括号内的一个字符                       |

举几个例子：

```shell
rm -rf *		# 删除所在目录下的所有文件
ls ?abc			# 列出以abc结尾的，名字为4位的所有文件
ls *abc			# 列出以abc结尾的所有文件
ls [0-9]*		# 列出以数字开头的所有文件
ls [^0-9]		# 列出不以数字开头的所有文件
```

| 特殊符号 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| `''`     | 单引号。在单引号中所有的特殊符号，如`$`和``` `（反引号）都没有特殊含义 |
| `""`     | 双引号。在双引号中特殊符号都没有特殊含义，但是`$`、``` `和`\`是例外，拥有**调用变量的值**、**引用命令**、**转义符**的特殊含义 |
| ``` `    | 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和`$()`作用一样，不过推荐使用`$()`，因为反引号非常容易看错 |
| `$()`    | 和反引号作用一样，用来引用系统命令                           |
| `#`      | 在Shell脚本中，#开头的行代表注释                             |
| `$`      | 用于调用变量的值，如需要调用变量name的值时，需要用`$name`的方式得到变量的值 |
| `\`      | 转义符，跟在`\`之后的特殊符号将失去特殊含义，变为普通字符<br />如`\$`将输出$符号，而不当做是变量引用。 |



## Bash变量

- 在Bash中，变量的**默认**类型都是**字符串**类型，如果要进行数值运算，则必须指定变量类型为**数值型**
- 变量用`=`连接，等号左右两侧不能有空格
- 变量的值如果有空格，需要使用单引号` `` `或者`""`包括（因为空格在shell中，默认为分割符）
- 在变量的值中，可以使用`\`转义符
- 如果需要增加变量的值，那么可以进行变量值的累加。不过变量需要用`""`包含
  - `"$变量名"`
  - `${变量名}`
- 如果把命令的结果作为变量值赋予变量，则需要使用反引号或者`$()`包含命令
- 环境变量名建议大写，便于区分

**变量的分类**

> - 用户自定义变量
> - 环境变量：这种变量中主要保存的是和系统操作环境相关的数据
> - 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。
> - 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。

### 用户自定义变量（本地变量）

用户自定义变量只存在于当前shell中，父Shell和子Shell都访问不到

```shell
name=$(date)
name2=${name}abc  # 变量叠加
name3="$name"abc  # 变量叠加
echo $name2
# set命令可以查看所有变量
set
# 删除变量
unset 变量名
```



### 环境变量

用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效。

- 设置环境变量 `export 环境变量名=环境变量值`
- 查询环境变量 `env`
- 删除环境变量 `unset`

:bulb:**补充命令**

> `pstree`：查看进程树

#### 系统常见的环境变量

- PATH：系统查找命令的路径

  - PATH用`:`进行分隔

    - > ```shell
      > yu@PC:~$ echo $PATH 
      > /home/yu/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
      > ```

  - PATH变量叠加

    - > ```shell
      > PATH="$PATH":/root/sh
      > 
      > PATH=${PATH}:/root/sh
      > ```

- PS1：定义系统提示符的变量

  - | 符号 | 说明                                                         |
    | ---- | ------------------------------------------------------------ |
    | `\d` | 显示日期，格式为：“星期  月  日”                             |
    | `\h` | 显示简写主机名。如默认的主机名“localhost”                    |
    | `\t` | 显示24小时制时间，格式为“HH:MM:SS”                           |
    | `\T` | 显示12小时制时间，格式为“HH:MM:SS”                           |
    | `\A` | 显示24小时制时间，格式为“HH:MM”                              |
    | `\u` | 显示当前用户名                                               |
    | `\w` | 显示当前所在目录的完整名称                                   |
    | `\W` | 显示当前所在目录的最后一个目录                               |
    | `\#` | 执行的第几个命令                                             |
    | `\$` | 提示符。如果是root用户会显示提示为"#"，如果是普通用户，会显示提示符为“$” |

  - > ```shell
    > yu@PC:~$ echo $PS1
    > \[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$
    > 
    > # 重新设置PS1变量
    > yu@PC:~$ PS1='[\u@\h \t \w]:\#\$'
    > [yu@PC 15:53:58 ~]:9$
    > # [用户名@主机名 时间 完整目录]:执行的第几个命令 提示符
    > ```





### 位置参数变量

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| `$n`         | n为数字，`$0`代表命令本身（执行的是什么命令，`$0`就是什么），`$1`~`$9`代表第1到第9个参数，十以上的参数需要用大括号包含，如`${10}` |
| `$*`         | 这个变量代表命令行中所有的参数，`$*`把所有的参数看成一个整体· |
| `$@`         | 这个变量也代表命令行中所有的参数，不过`$@`把每个参数区分对待 |
| `$#`         | 这个变量代表命令行中所有参数的个数                           |

**求两个数的和**

```shell
#!/bin/bash

num1=$1
num2=$2

sum=$(($num1+$num2))
echo -e "\e[1;32m $sum \e[0m"
```



```shell
yu@PC:~/bin$ cat ./test1.sh 
#!/bin/bash

echo "A total of $# parameters"

echo "The parameters are : $*"

echo "The parameters are : $@"
yu@PC:~/bin$ test1.sh 1 2 3 4 5 6
A total of 6 parameters
The parameters are : 1 2 3 4 5 6
The parameters are : 1 2 3 4 5 6

```

`$* 与 $@`的区别

```shell
for i in "$*"
	do
		echo "The parameter is: $i"
	done
x=1
for y in "$@"
	do
		echo "The parameter$x is : $y"
		x=$(($x + 1))
	done

```



### 预定义变量



| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| `$?`       | 最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了<br />举个具体的例子：<br />`命令1&&命令2`或者`命令1||命令2`怎么判断前一条命令是否正确执行呢？通过`$?`即可判断 |
| `$$`       | 当前进程的进程号（PID）                                      |
| `$!`       | 后台运行的最后一个进程的PID                                  |



### 接收键盘输入

```shell
yu@PC:~$ read [选项] [变量名]
选项：
	-p "提示信息"		在等待read输入时，输出提示信息
	-t 秒数			 read命令会一直等待用户输入，使用此选项可以指定等待时间
	-n 字符数			read命令只要接受指定的字符数，就会执行（不用等待回车）
	-s				  隐藏输入的数据，适用于机密信息的输入
```



```shell
yu@PC:~/bin$ cat ./readDemo.sh 
#!/bin/bash
# 提示“请输入姓名”并等待30s，把用户的输入保存在变量name中
read -t 30 -p "Please input your name: " name
echo "Name is $name"

# 年龄是隐私，所以我们使用 -s 选项来隐藏输入
read -s -t 30 -p "Please enter your age" age
echo -e "\n"
echo "Age is $age"

# 使用“-n 1”选项只接收输入字符就会执行，（都不用输入回车）
read -n 1 -t 30 -p "Please select your gender[M/F]:" gender
echo -e "\n"
echo "Sex is $gender"

yu@PC:~/bin$ vim readDemo.sh
yu@PC:~/bin$ chmod 755 ./readDemo.sh 
yu@PC:~/bin$ readDemo.sh 
Please input your name: luyu
Name is luyu
Please enter your age

Age is 12
Please select your gender[M/F]:M

Sex is M
```





## 数值运算与运算符

```shell
aa=11
bb=22
cc=$aa+$22
echo $cc

输出： 11+22
原因： shell变量的默认类型全部为 字符串 类型
```

### 数值运算

#### declare 声明变量类型

```shell
declare [+/-][选项] 变量名
选项：
	-			给变量设定类型属性
	+			取消变量的类型属性
	-i			将变量声明为正数型（integer）
	-x			将变量声明为环境变量
	-p			显示执行变量的被声明的类型
```

#### 方法1：declare声明类型

```shell
aa=11
bb=22
declare -i cc=$aa+$bb
```

#### 方法2：expr或let数值运算工具

```shell
aa=11
bb=22
dd=$(expr $aa + $bb)  # 注意，这里面加号左右必须有空格
echo $dd
33
```

#### 方法3：$((运算式)) 或 $[运算式]   (推荐)

```shell
aa=11
bb=22
ff=$(($aa+$bb))
gg=$[$aa+$bb]
```



### 运算符

| 优先级 | 运算符                                       | 说明                               |
| ------ | -------------------------------------------- | ---------------------------------- |
| 13     | `-, +`                                       | 单目负， 单目正                    |
| 12     | `!, ~`                                       | 逻辑非，按位取反或补码             |
| 11     | `*, /, %`                                    | 乘、除、取模                       |
| 10     | `+, -`                                       | 加、减                             |
| 9      | `<< , >>`                                    | 按位左移、按位右移                 |
| 8      | `<=, >= < >`                                 | 小于或等于，大于或等于，小于，大于 |
| 7      | `==, !=`                                     | 等于，不等于                       |
| 6      | `&`                                          | 按位与                             |
| 5      | `^`                                          | 按位异或                           |
| 4      | `|`                                          | 按位或                             |
| 3      | `&&`                                         | 逻辑与                             |
| 2      | `||`                                         | 逻辑或                             |
| 1      | `=, +=, -=, *=, /=,%=, &=, ^=, |=, <<=, >>=` | 赋值，运算且赋值                   |



### 变量测试 与 内容替换















































