
---
title: 2021年8月秋招复习笔记
---



# Java基础复习（JDK1.8）



## 容器篇

### 1.ArrayList

关键源码

```java
    /**
     * Default initial capacity.
     */
		// 默认初识容量为10
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * Shared empty array instance used for empty instances.
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * Shared empty array instance used for default sized empty instances. We
     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
     * first element is added.
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    transient Object[] elementData; // non-private to simplify nested class access

		// 调用空参数构造方法之后，列表还是一个空的列表
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

	    /**
     * The maximum size of array to allocate.
     * Some VMs reserve some header words in an array.
     * Attempts to allocate larger arrays may result in
     * OutOfMemoryError: Requested array size exceeds VM limit
     */
		// 最大可库容的容量阈值， 当容量超过这个值的时候，ArrayList的最大容量为Integer.MAX_VALUE
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

		// 添加元素
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
		// 扩容关键性代码
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);  // 每次扩容为原来的1.5倍
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity; //扩容后如果不够，那么就直接扩容为当前容量+1
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);  // 通过拷贝数据中的元素到新的数组，进行扩容
    }
		// 判断是否超过最大的扩容阈值
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
```

**总结：**

- ArrayList底层是通过数组实现的
- ArrayList的默认容量为10；
- ArrayList为懒加载，只有在添加了第一个元素之后才会真正分配空间
- 扩容时，每次扩容为原来容量的1.5倍：原来的容量值+容量值>>1
- 如果扩容后容量超过Integer.MAX_VALUE-8，ArrayList的容量就为Integer的最大值
- 每次扩容时，是通过将旧的数组中的元素拷贝到扩容后的新的数组中
- 查询、更新元素效率高



### 2.LinkedList

- LinkedList底层是通过双向链表实现的
- 可以当成Stack与Queue来实现
- 插入，删除元素效率高



### 3.HashMap

[HashMap原理](https://editor.csdn.net/md/?articleId=113561579)

小总结：

- 初识主数组长度：16（1<<4）
- 主数组最大长度：2^30
- 默认的负载因子0.75
- 链表树化阈值1：8
- 链表树化阈值2：主数组table长度超过64
- 红黑树退化成链表阈值：树节点少于6

> HashMap的主数组长度需要满足2的幂次方
>
> 比如输入为1，table长度为2
>
> 输入长度为15，table长度为16

#### HashMap插入元素底层原理

1. 插入元素前对key的HashCode进行扰动函数hash()计算

   1. > 现获取key的hashCode的值h，然后将h与h的高16位进行异或运算
      >
      > 其目的是在进行路由寻址的时候，能够保证在元素个数较少的情况下，路由地址会同时保持高16位和低16位的共同特征

2. 插入元素

   1. > **路由公式： i=hash & (table.length - 1)**
      >
      > 为什么是table.length - 1，而不是table.length呢？
      >
      > 因为table.length为2的幂次方计算出来（1000000000），0多1少
      >
      > 直接与hash进行&运算的时候，都会变为0，更容易发生hash冲突
      >
      > -1的目的就是将众多的0变为1，*与运算之后的值更不容易相同，缓解hash冲突。*

   2. >路由地址计算出来后，就要插入元素
      >
      >**插入情景1**：主数组i位置为null（没有冲突），直接插入元素
      >
      >**插入情景2**：主数组i位置存在元素，且key值相同，就新的value值覆盖旧的value值
      >
      >**插入情景3**：主数组i位置存在元素，且没有树化，尾插法插入链表
      >
      >​                      如果链表长度超过8，同时主数组长度打到64， 才开始树化
      >
      >**插入情景4**：主数组i位置存在元素，且已经树化成红黑树，向红黑树中插入元素

3. 元素插入达到阈值，进行扩容

   1. > 阈值计算：当前主数组长度 * 负载因子

   2. 主数组每次扩容原来的一倍：通过向左移位来实现（避免经过乘法器，耗性能）

   3. 扩容情景：

      1. 主数组对应的slot内没有元素（null），不做处理

      2. 主数组对应的slot内有元素，但是没有链化，直接用改元素的扰动值hash直接与（新的数组长度-1）进行&运算，计算出新的位置

      3. 主数组对应的slot内有元素，但是已经链化了

         1. > 这时就需要进行高低链分链
            >
            > 用key的hash值（扰动后的）与扩容前的旧容量进行&运算，如果为0，即为低链；不为0,即为高链
            >
            > 低链的元素扩容后还在**原索引**位置；高链的元素扩容后在**原索引+旧容量**处

         2. 如果是红黑树进行分链的时候，可能元素会少于6个，这个时候就需要退化成链表

<font color=red>HashMap在高并发的情况下，链表会出现环形链表</font>

<font color=green>这里提及一道经典面试题：如何判断一个链表是否有环？？？</font>

使用快慢指针（double pointer）

slow和fast：slow每次走一步，fast每次走两步；如果两个指针能相遇，一定存在环儿；

（<font color=blue>生活中的例子：两个人跑圈，快的人在第二圈的时候一定会遇到慢的那个人</font>）

### 4.线程安全的容器

上述提及的容器类都是线程不安全的容器类，在并发环境下应该避免使用

#### 线程安全的List

```java
List list = new ArrayList<>(); // 效率高，不支持并发


List list = new Vector<>(); // 线程安全，但是效率低
/**
vector 在添加元素的一些操作的方法，添加了synchronized关键，进行上锁，效率比较低
*/

List list = Collections.synchronizedList(new ArrayList<>()); // 线程安全，小数量完全可以
/*
synchronizedList内部是通过在具体的操作上包裹synchronized关键字，而不是粗暴的同步整个方法

*/


List list = new CopyOnWriteArrayList<>(); // 线程安全，JUC包下的类（写时复制）,适用于多线程环境

/*
每次添加元素的时候，先将集合中的元素复制到一个长度+1的新的数组中，然后将新增的元素添加到新的数组中，然后再将数组引用指向新的数组中。

这就保证了：读和写是在不同的对象上进行的，所以不存在资源竞争关系，不需要加锁
					读写分离思想
*/
```

#### 线程安全的HashMap

```java
// Collections.synchronizedMap
Map<Object, Object> synchronizedMap = Collections.synchronizedMap(new HashMap<>());

// ConcurrentHashMap
ConcurrentHashMap<Object, Object> map = new ConcurrentHashMap<>();
```

##### ConCurrentHashMap

1.7 [ConCurrentHashMap小灰漫画](https://zhuanlan.zhihu.com/p/31614308)













## JVM篇

JVM：java虚拟机，能够识别.class文件，能够将class文件中的字节码指令进行识别并调用操作系统向上的API完成动作。

JRE：Java运行时环境。主要包括两个部分：JVM的标准实现和java的一些基本类库。相对于jvm来说，jre多出来一部分java类库

JDK：Java开发工具包。是整个Java开发的核心，继承了jre和一些好用的小工具。

### 1.JVM的内存构成

JAVA内存构成包括：**堆、java栈**、本地方法栈、程序计数器

jdk1.8之后，方法区（元空间并不在jvm中了，而是使用本地内存）

#### 1.1 程序计数器（PC寄存器）

##### 作用

- 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制
- 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次执行到哪了。

##### 特点

- 是一块较小的内存空间
- 线程私有，每条线程都有自己的程序计数器
- 生命周期：随着线程的创建而创建，随着线程的结束而销毁
- 是唯一一个不会出现OutOfMemroyError的内存区域

#### 1.2 Java虚拟机栈（Java栈）

##### 定义

Java虚拟机栈是描述Java方法运行过程的内存模型

Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口信息
- .......

![875223b19a3ea457678d5a09acb950e0](https://github.com/wangzhiwubigdata/God-Of-BigData/raw/master/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.resources/6F3902DB-275A-4FC6-8E3A-754DE6F987BA.jpg)



##### 压栈出栈过程

当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。

Java虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。

方法结束之后，当前栈帧被移除，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。

> 由于Java虚拟机栈是线程对应的，数据不是线程共享的，因此不同关系数据一致性问题，也不会存在同步锁的问题。

##### Java栈的特点

- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。
- Java栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError
  - StackOverFlowError若Java虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，抛出StackOverFlowError异常
  - OutOfMemoryError若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出OutOfMemoryError异常。
- Java栈也是线程私有的，随着线程的创建而创建，随着线程的结束而销毁。

> 出现StackOverFlowError时，内存空间可能还有很多。

#### 1.3 本地方法栈（C栈）

##### 本地方法栈的定义：

本地方法栈是为JVM运行Native方法准备的空间，由于很多Native方法都是用C语言实现的，所以它通常又叫做C栈。它与Java虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

##### 栈帧变化过程

本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。

方法执行结束后，相应的栈帧也会出栈，并释放本地内存空间。也会抛出`StackOverFlowError`和`OutOfMemoryError`异常。

> 如果Java虚拟机本身不支持Native方法，或者本身不依赖与传统栈，那么可以不提供本地方法栈。如果本地支持方法栈，那么这个栈一般会在线程创建的时候按线程分配。

#### 1.4 Java堆Heap

##### 定义

堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中

##### 特点

- 线程共享，整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java栈、本地方法栈都是一个线程对应一个。
- 在虚拟机启动时创建。
- 是垃圾回收的主要场所
- 进一步可分为：新生代（Eden区， From Survivor、To Survivor）、老年代

不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。

堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因为当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出`OutOfMemoryError`

> Java堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。

##### 堆的划分

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200824152328561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center)

**逻辑上：**

- 新生代（Young）
  - Eden
  - 幸存区：From 和To
- 老年代（Old）
- 元空间

**物理上：**

物理上分为 **新生代+老年代**，而元空间使用的是直接内存

##### 内存分配策略

###### 1. 对象优先分配在Eden区

大多数情况下，对象在新生代Eden区中分配。当Eden去没有足够空间进行分配时，虚拟机将发起一次Minor GC。

👇**Minior GC vs Major GC**

- Minior GC：回收新生代（包括Eden和Survivor区域），因为Java对象大多都具备朝生夕灭的特性，所以Minior GC非常频繁，一般回收速度也比较快。
- Major GC：回收老年代，Major GC的速度一般会比Minor GC慢10倍以上。

###### 2.大对象直接进入老年代

大对象是指需要大量连续内存空间的Java对象，如很长的字符串或数据。

虚拟机提供了一个`-XX:PretenureSizeThreshold`参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden以及两个Survivor区之间发生大量的内存复制。

> 只要分配的对象的内存大小大于这个参数的时候就会直接分配到老年代

###### 3. 长期存活的对象将进入老年代（默认15）

JVM给每个对象定义了一个对象年龄计数器。当新生代发生一次Minor GC后，存活下来的对象年龄+1，当年龄超过`-XX:MaxTenuringThreshold, 默认为15`设置的值时，就将超过该值的所有对象转移到老年代中。

###### 4. 动态年龄判定

Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半

（`-XX:TargetSurvivorRatio 默认值为50， 意味Survivor区对象使用率阈值为50%` ），年龄大于或等于该年龄的对象直接进入老年代。

##### 老年代空间分配担保

什么是空间分配担保？

> 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间：
>
> ​	如果大于，则此次Minor GC是安全的
>
> ​	如果小于, 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。
>
> ​			如果`HandlePromotionFailure=true`，那么会继续检查老年代最大可用连续空间是否大于`历次晋升到老年代的对象的平均大小`，如果大于，则尝试进行一次Minor GC，但是这次Minor GC 依然是有风险的（<font color=green>因为Minor Gc之后，再次进入到老年代的对象的总大小有可能超过老年代最大可用连续空间</font>）
>
> ​			如果小于或者`HandlePromotionFailure=false`则改为进行一次Full GC

为什么要进行空间担保？

> 是因为新生代采用**复制收集算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。

总结起来：新生代存在大量存活的对象，Survivor无法容纳这些对象，老年代要进行空间分配担保；担保前要判断自生有没有能力，如果没有能力就需要触发Full GC。

#### 1.5 方法区

##### 方法区定义

Java虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放一下信息：

- 已经被虚拟机加载的类信息
- 常量
- 静态变量
- 即时编译器编译后的代码

##### 方法区的特点

- 线程共享。方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
- 内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载

##### 运行时常量池

方法区中存放：**类信息、常量、静态变量、即时编译器编译后的代码**。常量就存放在运行时常量池中



### 2. 垃圾收集策略&算法

#### 2.1 判断对象是否存活

1. **引用计数法**

> 在对象头维护着一个counter计数器，对象被引用一次则计数器+1；若引用失效则计数器-1.当计数器为0时，就认为该对象无效了。
>
> 引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。
>
> > 举个栗子👉对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。

2. **可达性分析（GC Roots）**

基本思路就是通过一些列名为”GC Roots“的对象作为起始点，开始向下搜索，如果一个对象到GCRoots没有任何引用链，就说明这个对象已经没有引用了，就可以作为垃圾。

也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可达到的）对象就被判定为存活，没有被遍历到的就自然判定为死亡对象。

###### 哪些对象可以作为GC Roots

- 虚拟机栈中的引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- synchronized同步的对象

GC Roots并不包括堆中对象引用的对象，这样就不会有循环引用的问题。



#### 2.1 垃圾收集算法

###### 标记-清除算法

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200824152623936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center)

缺点：内存会产生碎片化



###### 标记-复制

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200824152644220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center)

缺点：预留一半的内存区域；整个内存空间只有一半可以使用



###### 标记-整理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200824152724174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center)

缺点：标记整理虽然可以解决内存碎片化问题，也不存在内存空间浪费，但是需要移动存活的对象，但是，当内存中存活对象多，并且都是一些微小对象，而且垃圾对象较少时，要移动大量的存活对象才能换取少量的内存空间。



###### 分代收集算法

一块独立的内存区域只能使用一种垃圾回收算法，根据对象生命周期特征，将其划分到不同的区域，再对特定区域使用特定的垃圾回收算法，只有这样才能将垃圾回收算法的优点发挥到极致，这种组合的垃圾回收算法称之为：分代收集算法（分代回收算法）

根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。

- 新生代：复制算法
- 老年代：标记-清除算法、标记-整理算法



### 3. HotSpot垃圾收集器（7种）

#### 3.1 新生代垃圾收集器

##### 1. Serial GC收集器

![1c13b8e41120caccd15369497355b588.png](https://img-blog.csdnimg.cn/img_convert/1c13b8e41120caccd15369497355b588.png)

> 单线程，只会使用一个cpu或一条线程去完成垃圾收集工作，这也意味着在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束为止（<font color=red>臭名昭著的Stop The World</font>）
>
> **收集算法**：复制算法
>
> 与用户线程串行执行，单线程地好处就是减少上下文切换，减少系统资源的开销。但这种方式的缺点也很明显，在GC的过程中，会暂停程序的执行。若GC不是频繁发生，这或许是一个不错的选择，否则将会影响程序的执行性能。 对于新生代来说，区域比较小，停顿时间短，所以比较使用。
>
> **参数**：`-XX:+UseSerialGC` 
>
> 在JDK Client模式，不指定JVM参数，默认是串行垃圾收集器

##### 2. ParNew收集器

ParNew收集器是Serial GC的多线程版本，除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法(复制算法)、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。

![111fbad04e83f6fc486c78406621ae05.png](https://img-blog.csdnimg.cn/img_convert/111fbad04e83f6fc486c78406621ae05.png)

ParNew收集器除了使用了多线程收集外，其他与Serial收集器相比并无太多创新之外，但是它是许多运行在Server模式下的虚拟机首选的新生代收集器，其中有一个与性能无关的重要原因是，除了Serial收集器外，目前只有它能和CMS收集器配合工作。

> **算法**：复制算法
>
> 用于新生代
>
> GC时需要暂停所有用户线程，直到GC结束
>
> **参数**：
>
> ​	`-XX:+UseConcMarkSweepGC`：指定使用CMS后，会默认使用ParNew作为新生代收集器
>
> ​	`-XX:+UseParNewGC`：强制指定使用ParNew
>
> ​	`-XX:ParallelGCThreads`：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同

##### 3. Parallel Scavenge收集器（吞吐量优先）

Parallel收集器同样也采用了复制算法，并行回收和STW机制；和ParNew不同之处在于，Parallel收集器的目标则是达到一个可控制的吞吐量，也被称为吞吐量优先的垃圾收集器。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210128165345527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c3MzM1MTIz,size_16,color_FFFFFF,t_70)

> 参数：
>
> `-XX:MaxGCPauseMillis` 设置最大停顿时间STW，这参数设置的越小，停顿时间可能会缩短，但也会导致吞吐量下降，当值垃圾收集发生的更频繁。
>
> `-XX:GCtimeRatio` 垃圾收集时间占时间总比   用于衡量吞吐量
>
> ​	垃圾收集执行时间占应用程序执行时间的比例计算方法：`1/(n+1)`
>
> ​	例如`-XX:GCTimeRatio=19`,那么设置了垃圾收集时间占总时间的5% = 1/(19+1);
>
> ​	默认值是99，即1%；
>
> `-XX:UseAdaptiveSizePolicy` 设置Parallel收集器具有自适应调节功能；开启这个参数后，就不用手工指定一些细节参数了，如`新生代大小 -Xmn`、`Eden与Survivor区的比例 -XX:SurvivorRation`、`晋升老年代的对象年龄 -XX:MaxTenuringThreshold`

JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略(GC Ergonomiscs)；

另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。



#### 3.2 老年代垃圾收集器

##### 1. Serial Old收集器

![abdedea73525f71775a338dbceeedd2a.png](https://img-blog.csdnimg.cn/img_convert/abdedea73525f71775a338dbceeedd2a.png)

> **算法**：标记-整理
>
> 可作为CMS收集器的后备预案，并在CMS发生”Concurrent Mode Failure“ 时使用。



##### 2. Parallel Old

![e1b908c08120b3323a3d5ca408bc569b.png](https://img-blog.csdnimg.cn/img_convert/e1b908c08120b3323a3d5ca408bc569b.png)

Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先

> **算法**：标记-整理
>
> **参数**：`-XX:UseparallelOldGC` 指定使用Parallel Old收集器



##### 3. CMS并发清除（Concurrent Mark Sweep）

这个收集器有与工作线程执行**并发**的能力。

> **算法**：标记-清除
>
> **特点**：收集过程中不需要暂停用户线程，以获取最短回收停顿时间为目标

![ae5a11b458e117b8f30fdc064821647c.png](https://img-blog.csdnimg.cn/img_convert/ae5a11b458e117b8f30fdc064821647c.png)

CMS GC过程分四步：

1. **初始标记**（initial mark）

   > 单线程执行， 需要STW，但仅仅把GC Roots的直接关联可达的对象给标记一下，由于直接关联对象比较小，所以这里的速度非常快。

2. **并发标记**（Concurrent mark）

   > 对于初识标记过程所标记的初识标记对象，进行并发跟踪标记
   >
   > 此时其他线程仍可以继续工作。此处时间较长，但不停顿，并不能保证可以标记出所有的存活对象；

3. **重新标记**（remark）

   > 在并发标记的过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾。
   >
   > 此处执行**并行标记**，与用户线程不并发，所以依然是STW
   >
   > 且停顿时间比初识标记稍长，但远比并发标记短。

4. **并发清除**（Concurrent sweep）

   >  并发清除之前所有标记的垃圾；
   >
   > 其他用户线程仍可以工作，不需要停顿。

Tips：初始标记和并发标记仍然需要STW

**初始标记**仅仅标记一下GC Roots能直接关联到的对象，速度很快；

**并发标记**就是进行GC Roots Tracing的过程；

而**重新标记**阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段长，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程，收集器线程都可以与用户线程一起工作，所以整体上说，CMS收集器的内存回收过程是与用户线程一共并发执行的。

> **参数**：
>
> `-XX:+UseConcMarkSweepGC`：使用CMS收集器
>
> `-XX:+UseCMSCompactAtFullCollection`：Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长。
>
> `-XX:+CMSFullGCsBeforeCompaction`：设置进行几次Full GC后，进行一次碎片整理
>
> `-XX:ParallelCMSThreads`：设置CMS的线程数量（一般情况约等于可用CPU数量）

**优点**：

总体来说，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间；但却增加了新生代垃圾收集时应用暂停的时间，降低了吞吐量而且需要占用更大的堆空间；

由于耗时的**并发标记**和**并发清除**阶段都不需要暂停工作，所以整体的回收是低停顿的。

由于CMS以上特性，缺点也是比较明显的。

**缺点**：

1. 对CPU资源非常敏感

2. 浮动垃圾

   由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。

   由于在垃圾收集阶段用户线程还需要运行，那就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，也可以认为CMS所需要的空间比其他垃圾收集器大；

   `-XX:CMSInitiatingOccupancyFraction`: 设置CMS预留内存空间

3. ”Concurrent Mode Failure“失败

   如果如果CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样会导致另一次Full GC的产生。这样停顿时间就更长了，代价会更大，所以 `-XX:CMSInitiatingOccupancyFraction`不能设置得太大。

4. 产生大量内存碎片

   这个问题并不是CMS的问题，而是算法的问题。由于CMS基于"标记-清除"算法，清除后不进行压缩操作，所以会产生碎片

   "标记-清除"算法介绍时曾说过：

   产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。

   **碎片解决方法：**

   -  `-XX:+UseCMSCompactAtFullCollection`

     - 使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程；但合并整理过程无法并发，停顿时间会变长；

   - `-XX:+CMSFullGCsBeforeCompation`

     - 设置执行多少次不压缩的Full GC后，来一次压缩整理

     - 为减少合并整理过程的停顿时间；

       默认为0，也就是说每次都执行Full GC，不会进行压缩整理；

       由于空间不再连续，CMS需要使用可用"空闲列表"内存分配方式，这比简单使用"碰撞指针"分配内存消耗大；

       

#### 3.3 G1收集器

G1(Garbage - First)名称的由来是G1跟踪各个Region里面的垃圾堆的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

注意：G1与前面的垃圾收集器有很大不同，它把新生代、老年代的划分取消了！

这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。

取而代之的是，G1算法将堆划分为若干个区域(Region)，它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩(至少是部分堆的压缩)，这样也就不会有CMS内存碎片问题的存在了。
![d278aed530716ea4981a02fb8590c946.png](https://img-blog.csdnimg.cn/img_convert/d278aed530716ea4981a02fb8590c946.png)



G1收集器运作过程

![b03dfc84f0de89fe474936cbd70aef32.png](https://img-blog.csdnimg.cn/img_convert/b03dfc84f0de89fe474936cbd70aef32.png)

1. 初识标记

   - 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快

2. 并发标记

   - 进行GC Roots Tracing的过程，从刚才产生的集合中标记出存活对象；(也就是从GC Roots 开始对堆进行可达性分析，找出存活对象。)

     耗时较长，但应用程序也在运行；

     并不能保证可以标记出所有的存活对象；

3. 最终标记

   - 最终标记和CMS的重新标记阶段一样，也是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，

     这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，

     也需要“Stop The World”。(修正Remebered Set)

4. 筛选回收

   - 首先排序各个Region的回收价值和成本
   - 然后根据用户期望的GC停顿时间来制定回收计划；
   - 最后按计划回收一些价值高的Region中垃圾对象

   回收时采用”复制算法“，从一个或多个Region复制存活对象到堆上的另一个空间Region，并且再次过程中压缩和释放内存；

   可以并发进行，降低停顿时间，并增加吞吐量

   > **参数**：
   >
   > `-XX:+UseG1GC`：指定使用G1收集器
   >
   > `-XX:InitiatingHeapOccupancyPercent`: 当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；
   >
   > `-XX:MaxGCPauseMillis`： 为G1设置暂停时间目标，默认值为200毫秒；
   >
   > `-XX:G1HeapRegionSize`：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个

#### 小结：

![8d9b5b42d191a4ad452074f204507378.png](https://img-blog.csdnimg.cn/img_convert/8d9b5b42d191a4ad452074f204507378.png)







### 2.类加载过程

类从被加载到虚拟机内存中开始，到卸载出内存位置，他的整个生命周期如下如：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810150148636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E2NDY3MDU4MTY=,size_16,color_FFFFFF,t_70)

1. **加载**
   - 通过一个类的全限定名来获取定义此类的二进制字节流
   - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   - 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区数据的访问入口
2. **验证**
   - 验证阶段作用是保证Class文件的字节流包含的信息是否符合JVM规范，不会给JVM造成危害。如果验证失败，就会抛出一个java.lang.VerifyError异常或子类异常。验证过程分为四个阶段：
     - 文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理
     - 元数据验证：是对字节码描述的信息进行语义分析，以保证其描述信息符合Java语言的规范
     - 字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害JVM
     - 符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。

<font color=green>符号引用（Symbolic References）说明</font>

> 符号引用以一组符号来描述所引用的目标，符号引用与虚拟机的内存布局无关，引用的目标不一定加载到内存中。
>
> <font color=blue>在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替</font>
>
> 比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

3. **准备**

   - 准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量（实例变量在new 的时候初始化）。对已非final的变量，JVM会将其设置成”零值“，而不是其赋值语句的值：

     ```java
     private static int size = 12;
     ```

     那么这个阶段，size的值为0，而不是12。final修饰的类变量将会赋值成真实的值。

4. **解析**

   - 解析过程是将常量池内的符号引用替换成直接引用。主要包括四种类型引用的解析。**类或接口的解析**、**字段解析**、**方法解析**、**接口方法解析**。

5. **初始化**

   - 在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。

6. **使用**

7. **卸载**



### 3. 双亲委派机制



**java中的四种类加载器**

1. 启动（Bootstrap）类加载器

   > 启动类加载器是本地代码实现的类加载器，它负责将<JavaRuntimeHome>/lib下面的类库加载到内存中。由于启动类加载器涉及到虚拟机本地实现细节，开发者无法直接取到启动类加载器的引用。

2. 标准扩展（Extension）类加载器

   > 扩展类加载器负责将<JavaRuntimeHome>/lib/ext或者系统变量java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器

3. 应用程序（Application）类加载器

   > 应用程序类加载器负责加载用户路径（classpath）上的类库





![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMjAwNDkzNC8yMDIwMDcvMjAwNDkzNC0yMDIwMDcyOTEyNDgyNjk0MC0xMDQyODAzODI0LnBuZw?x-oss-process=image/format,png#pic_center)

**双亲委派机制**

> 当一个类收到类加载请求时，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）（从最顶层的BootStrap -》Extension-》Application-》自己定义的类加载器），子类加载器才会尝试自己加载。

**双亲委派机制的作用**

> 为了保证自己写的代码不污染java出厂自带的源代码。如果有人想替换系统级别的类：如String.java.篡改它的实现，但是在这种机制下这些系统的类已经被Bootstrap ClassLoader加载过了，所以并不会再去加载，从一定程度上防止了危险代码的植入。
>
> 1. 防止重复加载用一个.class。通过委托去上层，加载过了，就不用再加载一遍。保证数据安全
> 2. 保证了使用不同的类加载器最终得到的都是同一个Object对象。



### 3.创建（new）对象的过程

1. **检查类是否已经被加载**
   - 当JVM遇到一条字节码new指令时，首先检查该引用指向的类是否能够在常量池中被找到（也就是检查方法区中有没有该类的信息），如果没有，先加载这个类；有的话就执行下一步，为对象分配内存
2. **为对象分配内存空间**
   - 类加载检查通过后，接下来虚拟机会为对象分配内存。对象需要多大的内存在类加载完成后便可完全确定，为对象分配内存就是把一块确定大小的内存块从堆上划分出来。
3. **为对象字段设置零值**
   - 分配完内存后，需要对对象的字段进行零值初始化，（也就是对象的实例数据部分，对象的内存布局被分为三个部分：**对象头**、**实例数据**、**对齐填充**），对象头除外，零值初始化意思就是对对象的字段赋0值，或者null值。
4. **设置对象头**
   - 虚拟机需要对这个将要创建出来的对象，进行信息标记，包括是否为新生代/老年代，对象的hash码，元数据信息，这些标记存放在对象头信息中。
5. **执行构造方法**
   - 执行对象的构造方法，初始化对象，这样一个对象才算被成功创建。

### 4.对象的内存布局

> 提问：`Object o = new Object();` 请问一个object对象占多少内存空间？

Java对象的内存布局：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。8字节对齐。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201221191858529.png)

- Mark Word
  - 存储对象的hashCode、GC分代年龄、锁状态标志、线程只有的锁、偏向线程ID、偏向时间戳
- Class Pointer
  - 指向对象对应的Class对象（类对象）的内存地址
- Instance Date
  - 具体的数据大小，如对象含有一个int成员变量，即为4字节

在64bit的JVM中，MarkWord为64bit-8字节，这样一个`Object`对象占有**16个字节**



### 5. 四大引用类型



#### 1. 强引用

`StrongReference`是java的默认引用形式，使用时不需要显示定义。任何通过强引用所使用的对象，不管jvm内存是否充足，Java GC都不会主动回收具有强引用的对象。

> 如果一个对象具有强引用，那么垃圾收集器不会回收它
>
> 当JVM内存空间不足时，Java虚拟机宁愿抛出OurOfMemoryError错误，使程序异常终止，也不会回收强引用对象。

#### 2. 软引用

`SoftReference<String[]> softArr = new SoftReference<String[]>(new String[] {"a", "b", "c"});`

软引用在内存充足时，GC不会回收；如果内存不足时，GC会回收这个对象。

**应用场景**

> 实现内存敏感的高速缓存，比如网页缓存，图片缓存等。使用软引用能防止内存泄漏



#### 3. 弱引用

`WeakReference<String[]> weakArr=new WeakReference<String[]>(new String[]{"a","b","c"});`

如果一个对象只具有弱引用，无论内存充足与否，Java GC后对象都会被回收。

**应用场景**

> ThreadLocal

##### ThreadLocal 弱引用造成的数据泄漏问题

`ThreadLocalMap`内部Entry类

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
  /** The value associated with this ThreadLocal. */
  Object value;

  Entry(ThreadLocal<?> k, Object v) {
    super(k);
    value = v;
  }
}
```

可以看出，ThreadLocal内部每个线程维护的本地变量map中的Entry的key是弱引用类型`WeakReference`, 不管JVM内存空间是否充足，在GC的时候，都会回收里面的key。

<font color=red>但是value依然是强引用类型</font>，这就会造成这种情况：GC回收的时候，把key进行了回收，变为了`null`,但是其对应的value还有值存在，但是无法被引用到了，这就造成了`内存泄漏`,因此，在实际使用ThreadLocal的过程中，使用完毕后需要及时调用`remove()`方法，避免造成数据泄漏。



#### 4. 虚引用

虚引用需要配合引用队列`ReferenceQueue`联合使用。当执行Java GC时如果一个对象只有虚引用，就会把这个对象加入到与之关联的`ReferenceQueue`中。

```java
//虚引用PhantomReference
    //必须和引用队列联合使用
    ReferenceQueue<String[]> rqueue = new ReferenceQueue<>();
    PhantomReference<String[]> phanArr = new PhantomReference<String[]>(new String[]{"a","b"},rqueue);
    /**
     *
     * 应用场景：
     *大多被用于引用销毁前的处理工作
     *
     */
```

当垃圾回收期准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

程序可以通过判断引用队列中是否已经加入了虚引用，来了解引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列中，那么就可以在所引用的对象的内存被回收之前采取必要的行动。



### 6. JVM常用调优参数

[Oracle关于JVM参数配置参考表](https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html)

| 配置参数                             | 功能                                                         | 备注 |
| ------------------------------------ | ------------------------------------------------------------ | ---- |
| `-Xms`                               | 初识堆大小。如`-Xms256m`                                     |      |
| `-Xmx`                               | 最大堆大小。如`-Xmx1024m`                                    |      |
| `-Xmn`                               | 新生代大小。通常为`Xmx`的1/3或1/4.<br />新生代=Eden+2个Survivor空间。<br />实际可用空间为=Eden+1个Survivor，即90% |      |
| `-Xss`                               | 每个线程堆栈大小，默认为1M                                   |      |
| `-XX:NewRatio`                       | 老年代/新生代的比例，默认`-XX:NewRatio=2`,代表老年代：新生代=2：1 |      |
| `-XX:SurvivorRatio`                  | 新生代中Eden与Survivor的比值。默认值为8  `-XX:SurvivorRatio=8` |      |
| `java -XX:+PrintFlagsFinal -version` | 查看jvm所有参数选项的值                                      |      |
| `-XX:MaxTenuringThreshold`           | 新生代晋升老年的的年龄<br />默认值`-XX:MaxTenuringThreshold=15` |      |
| `-XX:MetaspaceSize`                  | 元空间大小                                                   |      |
| `-XX:MaxMetaspaceSize`               | 元空间最大空间大小                                           |      |
| `-XX:PretenureSizeThreshold`         | 大对象所占空间超过这个阈值，直接分配到老年代                 |      |
| `-XX:+PrintGCDetails`                | 打印GC信息                                                   |      |
| `关于设置垃圾收集器`                 |                                                              |      |
| `-XX:+UseSerialGC`                   | 新生代使用Serial GC， 老年代使用Serial old                   |      |
| `-XX:+UseParNewGC`                   | 新生代使用ParNew收集器，老年代使用Serial Old                 |      |
| `-XX:+UseConcMarkSweepGC`            | 新生代使用ParNew收集器，老年代使用CMS                        |      |
| `-XX:ParallelGCThreads=8`            | 这个参数指定并行GC线程的数量，<br />一般最好和cpu核心数相当。 |      |
| `-XX:+UseParallelOldGC`              | 新生代使用ParallelGC收集器，<br />老年代使用ParallelOldGC收集器 |      |
| `-XX:ConcGCThreads`                  | 设置CMS并发线程数                                            |      |
| `-XX:+UseG1GC`                       | 开启G1收集器                                                 |      |





## 并发与多线程篇

### 1. 进程与线程

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。

**进程与进程之间的通信方式**

1. 管道pipe
   - 通常指无名管道，unix系统IPC最古老的形式
   - 只能用于具有亲缘关系的进程之间的通信（父子进程，兄弟进程）
2. 命名管道FIFO
   - 在磁盘上有对应的节点，但是没有数据块。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。
3. 消息队列MessageQueue
   - 消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以从消息队列读取消息。
   - 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
   - 进程间通过消息队列通信，主要是：创建或打开消息队列，添加消息，读取消息和控制消息队列
4. 共享存储SharedMemory
   - 共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取策略读出，从而实现了进程间的通信。
   - 采用共享内存进行通信的一个主要好处是**效率高**，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：` 一次从输入文件到共享内存`和 `一次从共享内存输出文件`
5. 信号量Semaphore
   - 信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
6. 套接字Socket
   - 适合同一主机的不同进程间和不同主机的进程间进行全双工网络通信
7. 信号（sinal）



#### 线程的几种状态

`Thread.State`枚举类查看线程的各种状态

1. NEW（新建）
2. RUNNABLE（就绪）
3. BLOCKED（阻塞）
4. WAITING（等待）
5. TIMED_WAITING（超时等待）
6. TERMINATED（终止）



**wait/sleep都会导致线程的阻塞，有什么区别？**

- wait放开手去睡，放开手里的锁
- sleep握紧手去睡，醒了手里还有锁



#### Java中实现多线的方式

1. 继承Thread类，实现run方法
2. 实现Runnable接口，实现run方法
3. 实现Callable接口，实现call方法。注意：新建Thread的时候，Thread的构造方法中没有接收Callable的。（中间商赚差价！！！）所有我们需要找到一个既可以联系Runnable接口又联系Callable接口的类（FutureTask））
   - `FutureTask`中的`get()`方法会阻塞线程，一直等待线程计算完成后才执行下面的后续代码。一般放在最后。
   - 同一个futureTask对象只能被线程调用一次，当有新的线程调用了已经被调用过的futuretask对象时，这次只会复用上一次的结果，不会再执行一次。
4. 线程池`ExecutorService`(ThreadPoolExecutor类)





### 2. JUC

#### JUC强大的辅助类：

##### 1. CountDownLatch类

计数器不为0，`countDownLatch.await(); `方法后面的代码都被一直阻塞

每调用一个线程，就需要执行`countDownLatch.countDown()`,将其计数器减一

##### 2. CyclicBarrier

一句话：集齐七颗龙，召唤神龙。

没调用一个线程，就需要执行`cyclicBarrier.await()`,将计数器加1

**CyclicBarrier类与CountDownLatch类的区别**

| CountDownLatch                                               | CyclicBarrier                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 减计数方式                                                   | 加计数方式                                                   |
| 计算为0时释放所有等待的线程                                  | 计数达到指定值时释放所有等待线程                             |
| 计数为0时，无法重置                                          | 计数达到指定值时，计数置为0重新开始                          |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用                                                 | 可重复利用                                                   |

##### 信号量：Semaphore类（类似于PV操作）

两个关键性操作：

1. `semaphore.acquire()` 请求资源
2. `semaphore.release() ` 释放资源

> acquire：当一个线程调用acquire操作时，它要么成功，获取信号量（信号量-1）；要么一直等待下去，直到有线程释放了信号量，或者超时
>
> release：实际上会将信号量的值加1，然后唤醒等待的线程。

信号量的主要作用：

> 用于**对多个共享资源的互斥使用**
>
> 用于**并发线程数的控制**



### 阻塞队列（BlockingQueue）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823081540511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center)

线程1往阻塞队列中生产元素，线程2 从阻塞队列中消费元素。

阻塞队列满了，生产线程阻塞；

阻塞队列空了，消费线程阻塞。

***阻塞队列的用处***

> 在多线程领域：所谓阻塞，在某些情况下会 挂起 线程（即阻塞），一旦满足条件，被挂起的线程又会被自动唤醒。
> 为什么需要BlockingQueue，好处是我们不需要关心什么时候 需要阻塞线程，什么时候需要唤醒线程因为这一切BlockingQueue都给你一手包办了



| 实现类                                     | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| <font color=red>ArrayBlockingQueue</font>  | 由数组结构组成的有界阻塞队列                                 |
| <font color=red>LinkedBlockingQueue</font> | 由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列 |
| <font color=red>SynchrousQueue</font>      | 不存储元素的阻塞队列，也即单个元素的阻塞队列                 |
| PriorityBlockingQueue                      | 支持优先级排序的无界阻塞队列                                 |
| DelayQueue                                 | 使用优先级队列实现的延迟无界阻塞队列                         |
| LinkedTransferQueue                        | 由链表组成的无界阻塞队列                                     |
| LinkedBlockingDeque                        | 由链表组成的双向阻塞队列                                     |





### 3. 线程池

```java
public ThreadPoolExecutor(
  												// 常驻核心线程数
  												int corePoolSize,
  												// 最大线程数
                          int maximumPoolSize,
  												// 空闲线程的存活时间，
                          long keepAliveTime,
  												// 时间单位
                          TimeUnit unit,
  												// 阻塞队列：用于存放被提交但尚未被执行的任务，类似于银行的候客区：窗口已经满了，需要排队等待
                          BlockingQueue<Runnable> workQueue,
  												// 线程池中工作线程的线程工厂，用于创建线程。
                          ThreadFactory threadFactory,
  												// 拒绝策略（阻塞队列满了，无法再容纳更多的线程任务）
                          RejectedExecutionHandler handler) {
  if (corePoolSize < 0 ||
      maximumPoolSize <= 0 ||
      maximumPoolSize < corePoolSize ||
      keepAliveTime < 0)
    throw new IllegalArgumentException();
  if (workQueue == null || threadFactory == null || handler == null)
    throw new NullPointerException();
  this.acc = System.getSecurityManager() == null ?
    null :
  AccessController.getContext();
  this.corePoolSize = corePoolSize;
  this.maximumPoolSize = maximumPoolSize;
  this.workQueue = workQueue;
  this.keepAliveTime = unit.toNanos(keepAliveTime);
  this.threadFactory = threadFactory;
  this.handler = handler;
}
```



#### 线程池拒绝策略

| 拒绝策略                                 | 说明                                                         | 备注 |
| ---------------------------------------- | ------------------------------------------------------------ | ---- |
| `ThreadPoolExecutor.AbortPolicy(默认)`   | 直接抛出RejectedExecutionException异常阻止系统正常运行       |      |
| `ThreadPoolExecutor.CallerRunsPolicy`    | **调用者运行**机制：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量（谁让你找我的，你回去找谁去） |      |
| `ThreadPoolExecutor.DiscardOldestPolicy` | 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。 |      |
| `ThreadPoolExecutor.DiscardPolicy`       | 该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果任务允许丢失，这是最好的一种策略。 |      |





### 4. volatile&JMM内存模型



#### JMM内存模型

<img src="https://img-blog.csdnimg.cn/20200824153251847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center#" alt="在这里插入图片描述" style="zoom:50%;" />

> JMM是java的内存模型，JMM定义了程序中各个共享变量的访问规则，即在虚拟机中奖变量存储到内存和从内存读取变量这样的底层细节。
>
> 设计JMM主要的目的是：屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
>
> 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方成为栈空间），工作内存是每个线程私有的数据区域，而Java内存模型中规定所有变量都存储在主存中，主存是共享内存区域，所有线程都可以访问。
>
> 但是线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量先从主存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主存。
>
> 不能直接操作主存中的变量，各个线程中的工作内存中存储着主存中的变量副本，因此不同线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主存来完成。



#### volatile

##### volatile特性：

1. **可见性**

   - 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的

   - > **volatile底层实现可见性的原理**
     >
     > 以两核CPU为例（双核）
     >
     > 由于cpu的速度要比内存快的多，为了弥补这个性能差异，cpu内核都会有自己的高速缓冲区，当内核运行线程执行一段代码时，首先将这段代码的指令集进行缓存行填充到高速缓存，如果非volatile变量，当CPU执行修改了此变量之后，会将修改后的值回写到高速缓存，然后再刷新到内存中。如果刷新回内存之前，由于是共享变量，那么core2中的线程执行的代码也用到了这个变量，这时变量的值依然是旧的。
     >
     > volatile关键字就会解决这个问题
     >
     > > 首先被volatile关键字修饰的共享变量在转换成汇编语言时，会加上一个lock为前缀的指令，当cpu发现这个指令时，立即做两件事：
     > >
     > > 1. <font color=green>将当前内核高速缓存行的数据立刻回写到内存；</font>
     > > 2. <font color=green>使其他内核里缓存了该内存地址的高速缓存中的数据无效。重写从主存中读取该数据</font>

2. **禁止指令重排**

   - volatile内存区的读写，通过加屏障来禁止指令重排列
   - LoadLoad屏障：对于这样的语句`Load1; LoadLoad; Load2`, 在`Load2`以及后续读取操作要读取的数据被访问前，要保证`Load1`要读取的数据被读取完毕。
   - StoreStore屏障：对于这样的语句`Store1;StoreStore;Store2`, 在`Store2`以及后续写入操作执行前，保证`Store1`的写入操作对其它处理器可见。
   - LoadStore屏障：对于这样的语句`Load1;LoadStore;Store2`,在`Store2`以及后续写入操作被刷出前，保证`Load1`要读取的数据被读取完毕
   - StoreLoad屏障：对于这样的语句`Store1;StoreLoad;Load2`,在`Load2`以及后续所有读取操作执行前，保证`Store1`的写入对所有处理器可见。

3. **不保证原子性**



### 5. synchronized原理

[深入分析Synchronized原理](https://www.cnblogs.com/aspirant/p/11470858.html)

```java
public class SynchronizedDemo {

    public synchronized void method(){
        synchronized (this){
            System.out.println(
                    "Synchronized Demo"
            );
        }
    }

    public static void main(String[] args) {
    }
}
```

上述代码通过 `javap -c -l -p .class`反编译成字节码结果如下：

``` java
Compiled from "SynchronizedDemo.java"
public class SynchronizedDemo {
  public SynchronizedDemo();
    descriptor: ()V
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return
    LineNumberTable:
      line 1: 0
    LocalVariableTable:
      Start  Length  Slot  Name   Signature
          0       5     0  this   LSynchronizedDemo;

  public synchronized void method();
    descriptor: ()V
    Code:
       0: aload_0
       1: dup
       2: astore_1
       3: monitorenter			// 一次 monitorenter
       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       7: ldc           #3                  // String Synchronized Demo
       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      12: aload_1
      13: monitorexit			// 两次monitorexit
      14: goto          22
      17: astore_2
      18: aload_1	
      19: monitorexit			// 两次monitorexit
      20: aload_2
      21: athrow
      22: return
    Exception table:
       from    to  target type
           4    14    17   any
          17    20    17   any
    LineNumberTable:
      line 4: 0
      line 5: 4
      line 8: 12
      line 9: 22
    LocalVariableTable:
      Start  Length  Slot  Name   Signature
          0      23     0  this   LSynchronizedDemo;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    Code:
       0: return
    LineNumberTable:
      line 12: 0
    LocalVariableTable:
      Start  Length  Slot  Name   Signature
          0       1     0  args   [Ljava/lang/String;
}

```

1. `monitorenter`：每个对象都是一个监视器锁（**monitor**）。当**monitor**被占用时就会处于锁定状态，线程执行`monitorenter`指令时，尝试获取**monitor**的所有权，过程如下：

> 1. 如果**monitor**的进入数为0，则该线程进入**monitor**，然后将进入数设置为1，该线程即为**monitor**的所有者；
> 2. 如果线程已经占有该**monitor**，只是重新进入，则进入**monitor**的进入数加1；
> 3. 如果其他线程已经占用了**monitor**，则该线程进入阻塞状态，知道**monitor**的进入数为0，再重新尝试获取**monitor**的所有权

2. `monitorexit`:执行`monitorexit`的线程必须是`objectref`所对应的`monitor`的所有者。指令执行时，`monitor`的进入数减1，如果减1后进入数为0，那线程退出`monitor`，不再是这个`monitor`的所有者。其他被这个`monitor`阻塞的线程可以尝试去获取这个`monitor`的所有权

> monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异常退出释放锁；

**Synchronized**的语义底层是通过一个monitor的对象来完成的。











### 6.锁&锁升级



### 7.AQS





















## 常用设计模式



### 1.单例模式









### 2.工厂模式







### 3.模板模式







### 4.代理模式







### 5.建造者模式









### 6.观察者模式



## 列举Java几个异常

### 

























